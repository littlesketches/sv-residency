<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <style>
        /* COLOUR PALETTES */
        :root {
            /** OLD BRAND GUIDELINES **/
            --svGreen:                            #9ACA3C;
            --gippslandGreen:                     #CED99E;
            --secondary_greatOceanBlue:           #0070BB;
            --secondary_hepburnClay:              #9B0B32;
            --secondary_meredithGold:             #E3BA5A;
            --campaign_corrangamiteEggplant:      #550055;
            --campaign_corrangamiteEggplantLight: #B273B2;
            --campaign_gannarawwaPink:            #D00236;
            --campaign_gannarawwaPinkLight:       #EE5F83;
            --campaign_surfCoastTeal:             #00848F;
            --campaign_surfCoastTealLight:        #47ABB4;
            --campaign_queenscliffeMarine:        #0A3055;
            --campaign_queenscliffeMarineLight:   #7991A9;
            --campaign_milduraOrange:             #D3410B;
            --campaign_milduraOrangeLight:        #F2855D;
            --campaign_otwaysGreen:               #008848;
            --campaign_otwaysGreenLight:          #8DBF87;
            --monochrome_youYangsGranite:         #B2B2B2;
            --monochrome_lakeMountainMorning:     #CCCCCC;
            --monochrome_mtBullaMist:             #E5E5E5;
            /** NEW BRAND GUIDELINES **/
            --chartLightGreen:  #cbe197;
            --chartGray:        #b1b1b0;
            --chartTeal:        #52baba;
            --chartEmerald:     #00502e;
            --chartPowderBlue:  #9bddfa;
            --chartGreen:       #77bf00;
            --chartDarkGreen:   #009857;
            --chartOrange:      #cea98d;
            --chartBlue:        #00568f;
            --chartPurple:      #816bb4;
            --chartLightGrey:   #cfcfcf;
            --chartYellow:      #ffd300;
        }
        body{
            margin: 0;
        }

        /****************************/
        /*** IMPORTED FONTS       ***/
        /****************************/
            @font-face {
                font-family: 'DIN Next LT Pro';
                src: local('DIN Next LT Pro Bold'), local('DIN-Next-LT-Pro-Bold'),
                    url('../fonts/DINNextLTPro-Bold.woff2') format('woff2'),
                    url('../fonts/DINNextLTPro-Bold.woff') format('woff'),
                    url('../fonts/DINNextLTPro-Bold.ttf') format('truetype');
                font-weight: 700;
                font-style: normal;
            }
            @font-face {
                font-family: 'DIN Next LT Pro';
                src: local('DIN Next LT Pro Bold'), local('DIN-Next-LT-Pro-Bold'),
                    url('../fonts/DINNextLTPro-Light.woff2') format('woff2'),
                    url('../fonts/DINNextLTPro-Light.woff') format('woff'),
                    url('../fonts/DINNextLTPro-Light.ttf') format('truetype');
                font-weight: 300;
                font-style: normal;
            }
            @font-face {
                font-family: 'DIN Next LT Pro';
                src: local('DIN Next LT Pro Ultra Light'), local('DIN-Next-LT-Pro-Ultra-Light'),
                    url('../DINNextLTPro-UltraLight.woff2') format('woff2'),
                    url('../DINNextLTPro-UltraLight.woff') format('woff'),
                    url('../DINNextLTPro-UltraLight.ttf') format('truetype');
                font-weight: 200;
                font-style: normal;
            }


            /***************************/
            /*****  TYPOGRAPHY       ***/
            /***************************/

            body{
                font-family: 'DIN Next LT Pro';
            }

            /***************************/
            /*****  GENERAL STYLING  ***/
            /***************************/
        .main-title{
            font-size: 30px;
            font-weight: bold;
            fill: var(--chartEmerald);
            dominant-baseline: 'hanging';
            mix-blend-mode: multiply;
        }
        .main-subtitle{
            font-size: 14px;
            fill: var(--chartEmerald);
            dominant-baseline: 'hanging';
            mix-blend-mode: multiply;
        }
        .total-exports-label{
            font-size: 16px;
            font-weight: bold;
            fill: var(--chartEmerald);
        }
        .total-exports-vol{
            font-size: 16px;
            font-weight: bold;  
            text-anchor: end;
            fill: var(--chartEmerald);
        }
        .total-material-name{
            font-size: 12px;
            font-weight: bold;
            fill: var(--chartEmerald);
        }
        .total-exports-chart-label,
        .total-material-vol{
            font-size: 10px;
            fill: var(--chartEmerald);
        }
        .total-material-vol{
            text-anchor: end;
        }
        .total-exports-total{
            font-size: 30px;
            font-weight: bold;
            /* stroke: var(--chartEmerald); */
            stroke-width: 0.75px;
            fill: transparent; 
            fill: var(--chartTeal)  
       }
        .state,
        .country{
            fill: var(--monochrome_mtBullaMist);
            stroke: #fff;
            stroke-width: 0.5px;
        }
        .country.export-country{
            fill: var(--chartTeal)
        }
        .state.victoria{
            fill: var(--chartEmerald);
        }
        .country-label,
        .country-label-pct{
            fill: var(--chartEmerald);
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            text-shadow: 2px 2px 5px #fff;
        }
        .country-label-pct{
            font-size: 10px;
        }
        .export-connector{
            stroke-width: 1;
            stroke: var(--chartEmerald);
            stroke: var(--chartTeal);
            mix-blend-mode: multiply;
            fill: none;
        }
        .info-page-bg{
            fill: var(--chartEmerald);
            fill: var(--chartTeal);
            opacity: 0.15;
        }
        .infopane-group text,
        .infopane-group .total-bar,
        .infopane-group .material-bar{
            fill: #fff;
            fill: var(--chartEmerald);
        }
        .info-page-header{
            font-size: 18px;
            font-weight: bold;
        }
        .info-page-subheader{
            font-size: 8px;
        }
        .country-total-vol{
            font-size: 12px;
            font-weight: bold;
        }
        .country-total-vol,
        .country-material-vol,
        .info-page-subheader.align-right{
            text-anchor: end
        }
        .country-list-name{
            font-size: 12px;
            font-weight: bold;
        }
        .country-material-vol,
        .country-material-name{
            font-size: 9px;
        }
        .total-bar.all-exports,
        .total-material-bar{
            fill: var(--chartEmerald);
        }
  </style>
</head>

<body>

  <div id = "map-container">
      <svg id ="map"></svg>
  </div>

  <!-- JavaScript Libraries -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.5.2/tabletop.min.js"></script>    
    <script>

    ////////////////////////////////////////
    ///// DATA AND VIS SETTINGS OBJECTS  ///
    ////////////////////////////////////////

        const settings = { 
            svgID:                  'map',
            year:                   '2019/20',              
            dims: {
                width:              1080,
                height:             720,
            },
            geometry: {              
                projection:         d3.geoMercator(),      // Choice of map projection (see d3 docs for standard projections, and add d3-geo-projection plugin for further projections)
                centerLong:         133.7,               // Used to center the map on Victoria
                centerLat:          -16.1,               // ..
                projectionScale:    400,                 // and scale the projection to fit the canvas (note: )
            },
            infoPane: {
                dims: {
                    width:      230,
                    height:     140,
                    rx:         10,
                    ry:         10    
                },
            }
        }
        const data = {
            list: {},
            byExportCountry: {},
            inputData: ''
        }



    /////////////////////////////////////////////////////////////////////////////////
    ///// INIT SEQUENCE | LOAD MAP SHAPE FILE AND META DATA AND CALL RENDER MAP   ///
    /////////////////////////////////////////////////////////////////////////////////

        // Load function - called by Tabletop library which retrieves the Google Sheet data and calls the parsing and rendering functions
        Tabletop.init({
            key: 	'https://docs.google.com/spreadsheets/d/1V5HL7zCHGETUCDT8-3ZiDm9XncmOTEo9WDSP1Xe3wd0/edit?usp=sharing',
            callback: async(loadedData) => {
                // 1. Parse export data
                await parseData(loadedData.byMaterialExportDestination)
                // 2. Load map data and call render map function
                Promise.all([		                               // Use Promise.all to load multiple data files
                    d3.json('data/world-110m.json'),			   // 0. World map
                    d3.json('data/states.geojson.txt'),			   // 1. Australian stats
                ]).then( mapData => {
                    renderMap(settings, mapData[0], mapData[1])	    // Renders map and export data annotation
                });
            },
            simpleSheet: false,
            wanted: [ 'byStream' , 'byMaterial', 'byWRRG', 'byMaterialExportDestination'  ]   // Specifies which Google sheets to bring in (and in what order)
        });



    ////////////////////////////////////////////
    ///// DATA PARSING AND SHAPING FUNCTION  ///
    ////////////////////////////////////////////

        // Parse input data for export volumes by country
        async function parseData(loadedExportData){
            const exportData = loadedExportData.elements
            // a. Parse export data ('numbers as numbers')
            exportData.forEach(d => {
                Object.entries(d).forEach( ([key, value]) => {
                    if(!isNaN(parseFloat(value.replace(/,/g, ''))) && key !== 'year'){ 
                        d[key] = parseFloat(value.replace(/,/g, ''))
                    } 
                })
            })
            // b. Extract lists 
            data.list.country = [...new Set(exportData.sort((a, b) => (a.Total < b.Total) ? 1 : -1).map(d => d.Destination).filter(d => d !== 'Others'))]            // Sort ensures list is ranked by total
            data.list.country.push('Others')               // 'Others' back  to end of array'                                                 
            data.list.materials = loadedExportData.columnNames.filter(d => d !== "year" && d !== "Destination" && d !== 'Total' && d !== 'exPathOffsetX' && d !== 'exPathOffsetY')      // Materials are in order of how they are in the raw data (i.e. change column order in data to re-order in vis)
            // c. Shape data by export country
            data.list.country.forEach(country => {
                exportData.forEach(d => {
                    if(d.Destination === country){
                        data.byExportCountry[country] = d
                    }
                })
            })
            // d. Store data for referencing in render 
            data.inputData = exportData
        }; // end parseData()

        // Render the map visualisation, using the map shape data and parse export data 
        function renderMap(settings, worldShapeData, statesShapeData){

            // 1. SPECIFY LAYOUT GROUPS: Layers appended in rendering order
            const svg = d3.select(`#${settings.svgID}`).attr('viewBox', `0 0 ${settings.dims.width} ${settings.dims.height}`),
                mapGroup = svg.append('g').classed('map-group', true),
                countries = mapGroup.append('g').classed('countries-group', true),
                ausStates = mapGroup.append('g').classed('aus-states-group', true),
                exportPaths = mapGroup.append('g').classed('export-path-group', true),
                annotation = mapGroup.append('g').classed('annotation-group', true),
                countryLabels = annotation.append('g').classed('country-labels-group', true),
                titles = annotation.append('g').classed('titles-group', true),
                infoPane = svg.append('g').classed('infopane-group', true)

            // 2. SPECIFY MAP PROJECTION AND MAP PROJECTION PATH GENERATOR
            const projection = settings.geometry.projection,				   // Specify map projection type
                path = d3.geoPath().projection(projection)                     // Path generator function

            projection.scale(settings.geometry.projectionScale)
                .center([settings.geometry.centerLong, settings.geometry.centerLat])
                .translate([600, 470])                  // Translate [x, y]  by pixels to centre the map

            const exportPathGenerator = (d) =>  "M" + d[0].x + "," + d[0].y  + "S" + d[1].x + "," + d[1].y  + " " + d[2].x + "," + d[2].y       // Path generator for a curved line

            // 3. ADD WORD AND VICTORIAN LGA MAP SHAPE
            countries.selectAll('path')
                .data(worldShapeData.features)
                .join('path')
                    .attr('id', d => helpers.slugify(d.properties.name) )
                    .attr('d', path)			
                    .attr('class',  d => `country ${helpers.slugify(d.properties.name)} ${helpers.slugify(d.properties.continent)} `)    

            ausStates.selectAll('path')
                .data(statesShapeData.features)
                .join('path')
                    .attr('id', d => helpers.slugify(d.properties.STATE_NAME) )
                    .attr('d', path)			
                    .attr('class',  d => `state ${helpers.slugify(d.properties.STATE_NAME)} `)    
            
            // 4. COLOR EXPORT COUNTRIES *(BY TOTAL) AND ADD COUNTY LABELS
            const colourScale = d3.scaleLinear()
                .domain(d3.extent(data.inputData.map(d => d.Total)))
                .range(['#9bddfa', '#52baba'])

            const exportPathScale = d3.scaleLinear()
                .domain(d3.extent(data.inputData.map(d => d.Total)))
                .range([0.25, 3])

            const totalExports = d3.sum(data.inputData.map(d => d.Total)),
                totalPaper =    d3.sum(data.inputData.map(d => d.Paper)),
                totalGlass =    d3.sum(data.inputData.map(d => d.Glass)),
                totalMetals =   d3.sum(data.inputData.map(d => d.Metals)),
                totalPlastics = d3.sum(data.inputData.map(d => d.Plastic)),
                totalOther =    d3.sum(data.inputData.map(d => d.Other))

            const vicBBox = document.getElementById('victoria').getBBox(),
                vic_cx =  vicBBox.x + vicBBox.width/2,
                vic_cy =  vicBBox.y + vicBBox.height/2

            data.list.country.filter(d => d !== 'Others').forEach( country => {
                const countryBBox = d3.select(`#${helpers.slugify(country)}`).node().getBBox(),
                    country_cx = countryBBox.x + countryBBox.width /2,
                    country_cy = countryBBox.y + countryBBox.height/2,
                    exportLinkCoords = [ 
                        {x: vic_cx,     y: vic_cy},
                        {x: d3.mean([vic_cx, country_cx]) + data.byExportCountry[country].exPathOffsetX, y: d3.mean([vic_cy, country_cy]) + data.byExportCountry[country].exPathOffsetY },
                        {x: country_cx, y: country_cy}
                    ],
                    exportTotalVol = data.byExportCountry[country].Total

                // a. Colour country by total volume exported
                d3.select(`#${helpers.slugify(country)}`)
                    .style('fill', colourScale(exportTotalVol))

                // b. Add country label and pct
                countryLabels.append('text')
                    .classed(`country-label ${helpers.slugify(country)}`, true)
                    .attr('transform', `translate(${country_cx}, ${country_cy -7})`)
                    .text(country)
                countryLabels.append('text')
                    .classed(`country-label-pct ${helpers.slugify(country)}`, true)
                    .attr('transform', `translate(${country_cx}, ${country_cy + 4   })`)
                    .text(helpers.numberFormatters.formatPct1dec(data.byExportCountry[country].Total / totalExports))

                // c. AddExport path from Vic
                exportPaths.append('path').classed(`export-connector ${helpers.slugify(country)}`, true)
                    .attr('d', exportPathGenerator(exportLinkCoords))  
                    .style('stroke-width', exportPathScale(exportTotalVol))
            })

            // 5. RENDER THE INFO PANE
            const infoPaneWidth = settings.dims.width * 0.25,
                infoPaneHeight = settings.dims.height,
                infoPaneMargin = { top: infoPaneWidth * 0.1, bottom: infoPaneHeight * 0.1, left: infoPaneWidth * 0.1,  right: infoPaneWidth * 0.1}

                // a. Position infoPane
                infoPane.attr('transform', `translate(${settings.dims.width - infoPaneWidth} , ${0})` )

                // b. Attach a backgound rect
                infoPane.append('rect').classed('info-page-bg', true)
                    .attr('width', infoPaneWidth)
                    .attr('height', infoPaneHeight)

                // c. Headers and subheaders
                const infoPaneHeader = infoPane.append('text').classed('info-page-header', true)
                    .attr('x', infoPaneMargin.left)
                    .attr('y', infoPaneMargin.top + 10)
                    .attr('dy', 0)
                    .text('Top ten export countries')
                    .call(helpers.wrap, infoPaneWidth - infoPaneMargin.left - infoPaneMargin.right, 1.1)
                
                infoPane.append('text').classed('info-page-subheader', true)
                    .attr('x', infoPaneMargin.left)
                    .attr('y', infoPaneMargin.top + infoPaneHeader.node().getBBox().height + 15)
                    .text('Country')

                infoPane.append('text').classed('info-page-subheader align-right', true)
                    .attr('x', infoPaneWidth - infoPaneMargin.right)
                    .attr('y', infoPaneMargin.top + infoPaneHeader.node().getBBox().height + 15)
                    .text('Tonnes exported')

                // d. Each country (groups)
                const countyGroupWidth = infoPaneWidth - infoPaneMargin.left - infoPaneMargin.right,
                    countryTotalMax =  d3.max(data.inputData.map(d => d.Total)),
                    countryBarScale = d3.scaleLinear()
                        .domain([0, countryTotalMax])
                        .range([0, countyGroupWidth]),
                    totalChartWidth = settings.dims.width /3,
                    totalMaterialMax = d3.max([totalPaper, totalGlass, totalMetals, totalPlastics, totalOther]),
                    totalBarScale = d3.scaleLinear()
                        .domain([0, totalMaterialMax])
                        .range([0, totalChartWidth])

                let countryGroupYpos = infoPaneMargin.top + infoPaneHeader.node().getBBox().height + 30       

                data.list.country.forEach((country, i) => {
                    const countryGroup = infoPane.append('g')
                        .attr('transform', `translate(${infoPaneMargin.left}, ${countryGroupYpos})`)
                    countryGroup.append('text').classed('country-list-name', true)
                        .text(`${i +1}. ${country}`)

                    const countryTotalVol = data.byExportCountry[country].Total
                    countryGroup.append('text').classed('country-total-vol', true)
                        .attr('x', countyGroupWidth )
                        .text(`${helpers.numberFormatters.formatComma(countryTotalVol)}`)
                    countryGroup.append('rect').classed(`total-bar ${helpers.slugify(country)}`, true)
                        .attr('x', 0)
                        .attr('y', 3)
                        .attr('height', 1.5)
                        .attr('width', countryBarScale(countryTotalVol))

                    // Add materials
                    if(i < 5 || country === 'Others'){
                        let materialsCounter = 0                
                        data.list.materials.forEach((material, i) => {
                            const materialMax =  d3.max(data.inputData.map(d => d[material]))
                                countryMateriaVol = data.byExportCountry[country][material],
                                materialYSpace = 13
                            if(countryMateriaVol > 0){      // Only add a material if its non-zero to save some space
                                countryGroup.append('text').classed('country-material-name', true)
                                    .attr('x', 0)
                                    .attr('y', 15 + materialsCounter * materialYSpace)
                                    .text(material)
                                countryGroup.append('text').classed('country-material-vol', true)
                                    .attr('x', countyGroupWidth )
                                    .attr('y', 15 + materialsCounter * materialYSpace)
                                    .text(`${helpers.numberFormatters.formatComma(countryMateriaVol)}`)
                                countryGroup.append('rect').classed(`material-bar ${helpers.slugify(material)}`, true)
                                    .attr('x', 0)
                                    .attr('y', 17 + materialsCounter * materialYSpace)
                                    .attr('height', 0.6)
                                    .attr('width', countryBarScale(countryMateriaVol))
                                materialsCounter ++
                            }
                        })
                    }

                    // Update start y pos for next country group
                    countryGroupYpos += countryGroup.node().getBBox().height + 10
                })

            // 6. ADD ANNOTATION
            const titleMargin = {left: 30, top: 40}
            // a. Main title
            titles.append('text').classed('main-title', true)
                .attr('x', titleMargin.left)
                .attr('y', titleMargin.top)
                .attr('dy', 0)
                .text(`Victorian recycled material exports`)
            titles.append('text').classed('main-subtitle', true)
                .attr('x', titleMargin.left)
                .attr('y', titleMargin.top + 20)
                .attr('dy', 0)
                .text(`a breakdown by export country and materials in ${settings.year}`)

            // b. Totals group (bottom left)
            const totalGroup = titles.append('g')
                .attr('transform', `translate(${titleMargin.left}, ${settings.dims.height - 250})`)
            totalGroup.append('text').classed('total-exports-label', true)
                .text(`Victoria exported`)
            totalGroup.append('text').classed('total-exports-total', true)
                .attr('y', 30)
                .text(`${helpers.numberFormatters.formatComma(totalExports)} tonnes`)
            totalGroup.append('text').classed('total-exports-label', true)
                .attr('y', 50)
                .text(`of recyclable material`)
            totalGroup.append('text').classed('total-exports-chart-label', true)
                .attr('y', 74)
                .text(`volumes by exported material`)

            // Add materials             
            data.list.materials.forEach((material, i) => {
                const  materiaVol = d3.sum(data.inputData.map(d => d[material])),
                    materialYSpace = 20
                totalGroup.append('text').classed('total-material-name', true)
                    .attr('x', 0)
                    .attr('y', 90 + i * materialYSpace)
                    .text(material)
                totalGroup.append('rect').classed(`total-material-bar ${helpers.slugify(material)}`, true)
                    .attr('x', 0)
                    .attr('y', 93 + i * materialYSpace)
                    .attr('height', 2)
                    .attr('width', totalBarScale(materiaVol))
                totalGroup.append('text').classed('total-material-vol', true)
                    .attr('x', totalChartWidth )
                    .attr('y', 90 + i * materialYSpace)
                    .text(`${helpers.numberFormatters.formatComma(materiaVol)} tonnes`)                    
            })
      }; // end renderMap()


    /////////////////////////////
    /// X HELPER FUNCTIONS    ///
    /////////////////////////////

    const helpers= {
        numberFormatters: {
            formatComma:           	d3.format(",.0f"),
            formatComma1dec:       	d3.format(",.1f"),
            formatComma2dec:       	d3.format(",.2f"),
            formatInteger:         	d3.format(".0f"),   
            formatCostInteger:     	d3.format("$,.0f"),  
            formatCost1dec:        	d3.format("$,.1f"),  
            formatPct:          	d3.format(".0%"), 
            formatPct1dec:          d3.format(".1%")  
        },
        numberParsers: {
            parseDateSlash: d3.timeParse("%d/%m/%Y")
        },
        slugify: function (str) {
            str = str.replace(/^\s+|\s+$/g, '').toLowerCase(); // trim           
            const from = "àáäâèéëêìíïîòóöôùúüûñç·/_,:;",      // remove accents, swap ñ for n, etc
                to   = "aaaaeeeeiiiioooouuuunc------"
            for (var i=0, l=from.length ; i<l ; i++) {
                str = str.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));
            }
            str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
                .replace(/\s+/g, '-') // collapse whitespace and replace by -
                .replace(/-+/g, '-'); // collapse dashes
            return str;
        }, 
        wrap: function(text, width, lineHeight) {
            text.each(function() {
                let text = d3.select(this),
                    words = text.text().split(/\s+/).reverse(),
                    word,
                    line = [],
                    lineNumber = 0,
                    y = text.attr("y"),
                    x = text.attr("x"),
                    fontSize = parseFloat(text.style("font-size")),
                    dy = parseFloat(text.attr("dy")),
                    tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));

                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan")
                            .attr("x", x)
                            .attr("y",  y)
                            .attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                    }                    
                }            
            })
        }
    }


  </script>
</body>

</html>